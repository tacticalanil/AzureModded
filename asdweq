--|| Library ||
local Library 			= {}

--|| Enviroment ||
getcustomasset 			= getcustomasset or function() end
base64_decode 			= base64_decode or crypt and crypt.base64decode or function() end
cloneref 				= cloneref or function(s) return s end
makefolder 				= makefolder or function() end
writefile 				= writefile or function() end
isfolder 				= isfolder or function() end
isfile 					= isfile or function() end
listfiles 				= listfiles or function() end
readfile 				= readfile or function() end
loadfile				= loadfile or function() return function() end end
delfile					= delfile or function() end

--|| Services ||
local ReplicatedStorage = cloneref(game:FindService("ReplicatedStorage"))
local UserInputService  = cloneref(game:FindService("UserInputService"))
local TweenService      = cloneref(game:FindService("TweenService"))
local HttpService 		= cloneref(game:FindService("HttpService"))
local RunService        = cloneref(game:FindService("RunService"))
local Workspace_        = cloneref(game:FindService("Workspace"))
local Players           = cloneref(game:FindService("Players"))
local Debris            = cloneref(game:FindService("Debris"))

--|| Variables ||
local LocalPlayer       = Players.LocalPlayer
local Character         = LocalPlayer.Character or LocalPlayer:WaitForChild("Character")

local Camera            = Workspace_.CurrentCamera
local Mouse             = LocalPlayer:GetMouse()

--|| Globals ||
local Wait_				= task.wait

local TCall				= coroutine.wrap
local PCall				= pcall

local Hex 				= Color3.fromHex
local Hsv 				= Color3.fromHSV
local Rgb 				= Color3.fromRGB

local Dim2 				= UDim2.new

local Floor 			= math.floor
local Clamp 			= math.clamp
local Max				= math.max
local Min				= math.min

local Split 			= string.split
local Match 			= string.match
local Format			= string.format
local Sub				= string.sub
local Lower				= string.lower

local Unpack			= table.unpack
local Find				= table.find
local Insert			= table.insert
local Remove			= table.remove
local Concat			= table.concat

local GetMeta			= getmetatable
local SetMeta			= setmetatable

--|| Functions ||
function Library:EnumString(enum)
	if typeof(enum) ~= "string" then
		return enum
	end

	if table.find({"MouseButton1", "MouseButton2", "MouseButton3"}, enum) then
		return Enum.UserInputType[enum] or enum
	end

	return Enum.KeyCode[enum] or enum
end

function Library:RegisterFont(_Font)
	local directory = `{ Library.Folders.Fonts }{ Library.Folders.Prefix }%s`

	if not isfile(Format(directory, _Font.ttf)) then
		writefile(Format(directory, _Font.ttf), base64_decode(game:HttpGet(_Font.url)))
	end

	if not isfile(Format(directory, _Font.json)) then
		_Font.info = {
			name = "Regular",
			weight = 200,
			style = "normal",
			assetId = getcustomasset(Format(directory, _Font.ttf))
		} 

		writefile(Format(directory, _Font.json), HttpService:JSONEncode({
			name = _Font.name,
			faces = {_Font.info}
		}))
	end

	Library.Fonts[_Font.name] = Library.Fonts[_Font.name] or Font.new(getcustomasset(Format(directory, _Font.json)), Enum.FontWeight.Regular)
	return Library.Fonts[_Font.name]
end

function Library:IsMouseOverFrame(Frame)
	local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize

	return Mouse.X >= AbsPos.X and Mouse.X <= AbsPos.X + AbsSize.X and Mouse.Y >= AbsPos.Y and Mouse.Y <= AbsPos.Y + AbsSize.Y
end

function Library:IsOverflowing(Frame, Parent)
	return Frame.AbsolutePosition.Y > (Parent.AbsolutePosition.Y + Parent.AbsoluteSize.Y) or Parent.AbsolutePosition.Y > (Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y)
end

function Library:Connection(Signal, callback)
	local Connection = Signal:Connect(callback)

	Insert(Library.Connections, Connection)
	return Connection
end

function Library:Disconnection(Connection)
	Connection:Disconnect()

	local index = Find(Library.Connections, Connection)

	if not index then return end

	Remove(Library.Connections, index)
end

function Library:Tween(_Instance, Info, Goal, _Wait)
	Info = TweenInfo.new(
		Info.Duration or 0.15, 
		Enum.EasingStyle[Info.Style or "Quad"], 
		Enum.EasingDirection[Info.Direction or "Out"],
		0,
		false,
		Info.DelayTime or 0
	)

	TweenService:Create(_Instance, Info, Goal):Play()

	if _Wait then
		Wait_(_Wait)
	end
end

function Library:CaseInsensitive(Table)
	local NewTable = {}

	if type(Table) ~= "table" then return end

	for key, value in Table do
		if type(key) == "number" then continue end
		NewTable[key:lower()] = NewTable[key:lower()] or value

		local metamethod = GetMeta(value)
		if not metamethod or type(NewTable[key:lower()]) ~= "table" then continue end

		SetMeta(NewTable[key:lower()], metamethod)
	end

	return SetMeta(NewTable, Library.Metamethods) 
end

function Library:Length(Table)
	local Count = 0

	for _, _ in Table do
		Count += 1
	end

	return Count
end

function Library:Keys(Table)
	local Keys = {}
	
	for Key, _ in Table do
		rawset(Keys, #Keys + 1, Key)
	end
	
	return Keys
end

function Library:Append(Variable, Target, PassKey, Key)
	local Target = Target

	if type(Variable) ~= "table" then
		if PassKey then 
			Target[Key] = Variable 
			return Target
		end

		Insert(Target, Variable)
		return Target
	end

	for index, value in Variable do
		if PassKey then 
			Target[index] = value 
			continue 
		end

		Insert(Target, value)
	end

	return Target
end

function Library:RGBToHSV(_Color3)
	local info = {
		r = _Color3.R,
		g = _Color3.G,
		b = _Color3.B,
	}

	if info.r > 1 or info.g > 1 or info.b > 1 then
		info.r /= 255
		info.g /= 255
		info.b /= 255
	end

	info.max = Max(info.r, info.g, info.b)
	info.min = Min(info.r, info.g, info.b)
	info.delta = info.max - info.min

	info.hue = info.delta == 0 and 0 or 
		info.max == info.r and ((info.g - info.b) / info.delta) or
		info.max == info.g and ((info.b - info.r) / info.delta) + 2 or
		info.max == info.b and ((info.r - info.g) / info.delta) + 4

	info.hue = (info.hue / 6) % 1

	info.sat = 0
	if info.max ~= 0 then
		info.sat = info.delta / info.max
	end

	info.val = info.max

	return {h = info.hue, s = 1 - info.sat, v = 1 - info.val}
end

function Library:RGBToTable(_Color3)
	if typeof(_Color3) ~= "Color3" then return end
	return {
		Library:Round(_Color3.R * 255, 1), 
		Library:Round(_Color3.G * 255, 1), 
		Library:Round(_Color3.B * 255, 1), 
	}
end

function Library:Drag(InputFrame, Frame, Callback)
	local Drag = {}
	Drag.StartPos = Dim2()

	Library:Connection(InputFrame.InputBegan, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Drag.Dragging = true
		Drag.StartPos = Frame.Position - Dim2(0, input.Position.X, 0, input.Position.Y)
	end)

	Library:Connection(InputFrame.InputEnded, function(input) 
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Drag.Dragging = false
	end)

	Library:Connection(UserInputService.InputChanged, function(input) 
		if not Drag.Dragging or input.UserInputType.Name ~= "MouseMovement" then return end

		Drag.Delta = Dim2(0, input.Position.X, 0, input.Position.Y) + Drag.StartPos

		Drag.Delta = Dim2(
			0,
			Clamp(Drag.Delta.X.Offset, 3, (Library.framework.AbsoluteSize.X  - Frame.AbsoluteSize.X) - 3),
			0,
			Clamp(Drag.Delta.Y.Offset, 3, (Library.framework.AbsoluteSize.Y - Frame.AbsoluteSize.Y) - 3)
		)

		Callback(Drag.Delta)
	end)
end

function Library:Resize(InputFrame, Frame, Info, Callback)
	local Resize = {}
	Resize.StartPos = Dim2()

	Library:Connection(InputFrame.InputBegan, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Resize.Resizing = true
		Resize.StartPos = Frame.Size - Dim2(0, input.Position.X, 0, input.Position.Y)
	end)

	Library:Connection(InputFrame.InputEnded, function(input) 
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Resize.Resizing = false
	end)

	Library:Connection(UserInputService.InputChanged, function(input) 
		if not Resize.Resizing or input.UserInputType.Name ~= "MouseMovement" then return end

		Resize.Delta = Dim2(0, input.Position.X, 0, input.Position.Y) + Resize.StartPos
		Resize.Delta = Dim2(0, Clamp(Resize.Delta.X.Offset, Info.minwidth, Info.maxwidth), 0, Clamp(Resize.Delta.Y.Offset, Info.minheight, Info.maxheight))

		Callback(Resize.Delta)
	end)

	return Resize
end

function Library:IndexFlag()
	Library.IndexFlags = Library.IndexFlags + 1

	return Library.IndexFlags
end

function Library:Random()
	return Sub(HttpService:GenerateGUID(), 2, 9)
end

--|| Folders ||
Library.Folders = {}

Library.Folders.Prefix      = "\\"
Library.Folders.Format      = "JSON"
Library.Folders.Main        = "Azure Modded"
Library.Folders.Configs     = `{ Library.Folders.Main}{ Library.Folders.Prefix }Configs`
Library.Folders.Fonts       = `{ Library.Folders.Main }{ Library.Folders.Prefix }Fonts`

if not isfolder(Library.Folders.Main) then
	makefolder(Library.Folders.Main)
end

if not isfolder(Library.Folders.Configs) then
	makefolder(Library.Folders.Configs)
end

if not isfolder(Library.Folders.Fonts) then
	makefolder(Library.Folders.Fonts)
end

--|| Tables ||
Library.Metamethods = {
	__index = function(self, key)
		return rawget(self, Lower(key))
	end,

	__newindex = function(self, key, value)
		return rawset(self, Lower(key), value)
	end
}

Library.Ignore = {
	7357609703
}

Library.Tabs = {}
Library.Configs = {}
Library.Keybinds = {}
Library.Connections = {}

Library.Friends = {}
Library.Priorities = {}

--|| Pre-Registered Fonts ||
Library.Fonts = {}

Library.FontRegistry = {
	{ ttf = "Proggy.ttf", json = "Proggy.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Proggy.txt", name = "Proggy" },
	{ ttf = "Minecraftia.ttf", json = "Minecraftia.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Minecraftia.txt", name = "Minecraftia" },
	{ ttf = "SmallestPixel7.ttf", json = "SmallestPixel7.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Smallest%20Pixel.txt", name = "SmallestPixel7" },
	{ ttf = "Verdana.ttf", json = "Verdana.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Verdana.txt", name = "Verdana" },
	{ ttf = "VerdanaBold.ttf", json = "VerdanaBold.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Verdana%20Bold.txt", name = "VerdanaBold" },
	{ ttf = "Tahoma.ttf", json = "Tahoma.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Tahoma.txt", name = "Tahoma" },
	{ ttf = "TahomaBold.ttf", json = "TahomaBold.json", url = "https://raw.githubusercontent.com/OxygenClub/Random-LUAS/main/Tahoma%20Bold.txt", name = "TahomaBold" }
}

Library.Fonts.Proggy            = Library:RegisterFont(Library.FontRegistry[1])
Library.Fonts.Minecraftia       = Library:RegisterFont(Library.FontRegistry[2])
Library.Fonts.SmallestPixel7    = Library:RegisterFont(Library.FontRegistry[3])
Library.Fonts.Verdana           = Library:RegisterFont(Library.FontRegistry[4])
Library.Fonts.VerdanaBold       = Library:RegisterFont(Library.FontRegistry[5])
Library.Fonts.Tahoma            = Library:RegisterFont(Library.FontRegistry[6])
Library.Fonts.TahomaBold        = Library:RegisterFont(Library.FontRegistry[7])

--|| Flags ||
Library.Flags = {}
Library.IndexFlags = 0

--|| Library Variables ||
Library.keynames = loadfile("keynames.txt")() or require(ReplicatedStorage.keynames)
Library.instances = loadfile("instances.txt")():create(Library.Fonts, Library.Fonts.Proggy) or require(ReplicatedStorage.instances)
Library.UIBind = Enum.KeyCode.Insert

Library.SetTextSize = Library.instances.textsizechange
Library.SetFont = Library.instances.fontchange
Library.SetTheme = Library.instances.themechange
Library.Round = Library.instances.round
Library.New = Library.instances.create
Library.Parent = game.CoreGui

--|| instances ||
Library.holder = Library:New("Folder", {
	Parent = Library.Parent
})

Library.framework = Library:New("ScreenGui", {
	IgnoreGuiInset = true,
	DisplayOrder = 100,
	Parent = Library.holder
})

Library.hud = Library:New("ScreenGui", {
	IgnoreGuiInset = true,
	DisplayOrder = 101,
	Parent = Library.holder
})

Library.notifs = Library:New("ScreenGui", {
	Parent = Library.holder,
	DisplayOrder = 102,
	IgnoreGuiInset = true,
	ZIndexBehavior = Enum.ZIndexBehavior.Sibling
})

--// Window
function Library:Create(info)
	info = Library:CaseInsensitive(info or {})

	local Window = {
		title = info.title or "Window",
		subtitle = info.subtitle or "UI Library",
		position = info.position or "center",
		open = info.open ~= nil and info.open or true,
		class = "window",

		width = info.width or 500,
		height = info.height or 600,

		minwidth = info.minwidth or 300,
		minheight = info.minwidth or 400,

		maxwidth = info.maxwidth or 700,
		maxheight = info.maxheight or 800,

		functions = {},
	}

	Window.tabholder, Window.buttonholder, Window.instances = 
		Library.instances.window(Library.framework, Window)

	Window.functions.title = function(str)
		Window.instances.title.Text = str
		Window.title = str
	end

	Window.functions.subtitle = function(str)
		Window.instances.subtitle.Text = str
		Window.subtitle = str
	end

	Window.functions.visible = function(bool)
		Window.open = bool == nil and not Window.open or bool
		Window.instances.outline.Visible = Window.open
	end

	Window.functions.position = function(dim2)
		Library:Tween(Window.instances.outline, {}, {Position = dim2})
	end

	Window.functions.size = function(dim2)
		Window.instances.outline.Size = dim2
	end

	Library:Resize(Window.instances.resize, Window.instances.outline, Window, function(delta)
		Window:Set("Size", delta)
	end)

	Library:Drag(Window.instances.title, Window.instances.outline, function(delta)
		Window:Set("Position", delta)
	end)

	Library:Connection(UserInputService.InputBegan, function(inp,gpe)
		if inp.KeyCode == Library.UIBind then 
			Window:Set("Visible")
		end
	end)

	return SetMeta(Window, Library)
end

--// Window / Tab
function Library:Tab(title, active)
	local Tab = {
		title = title or "Tab",
		active = active or #Library.Tabs == 0,
		class = "tab",

		functions = {}
	}

	local Window = self

	Tab.sectionholder, Tab.playerlist, Tab.instances = 
		Library.instances.tab(Window.tabholder, Tab)

	Library:Append(
		Library.instances.tab_button(Window.buttonholder, Tab),
		Tab.instances,
		true
	)

	function Tab.functions.active()
		for _, tab in Library.Tabs do
			tab.active = tab == Tab
			tab.instances.tab.Visible = tab.active
			tab.instances.liner.Visible = tab.active 
			tab.instances.hide.Visible = tab.active 

			Library:Tween(tab.instances.text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = tab.active and 1 or 0})
			Library:Tween(tab.instances.text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = tab.active and 0 or 1})
		end
	end

	Library:Connection(Tab.instances.inline.InputEnded, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Tab:Set("Active")
	end)

	Insert(Library.Tabs, Tab)
	return SetMeta(Tab, Library)
end

--// Window / Tab / Playerlist
function Library:Playerlist(title, callback)
	local Playerlist = {
		title = title or "Playerlist",
		callback = callback or function() end,

		connections = {},
		functions = {},
		players = {},
		class = "playerlist",
	}

	SetMeta(Playerlist, Library)

	local Tab = self

	Playerlist.object, Playerlist.instances = 
		Library.instances.player_list(Tab.playerlist, Playerlist)

	Playerlist.Section = Playerlist:Section("Playerlist")

	Playerlist.table = Playerlist.Section:Table({flag = Library:Random(), cfg = false})
	Playerlist.image = Playerlist.Section:Image({flag = Library:Random(), cfg = false})

	Playerlist.priority = Playerlist.image:Button({flag = Library:Random(), cfg = false, Title = "Priority"})
	Playerlist.friendly = Playerlist.image:Button({flag = Library:Random(), cfg = false, Title = "Friendly"})

	Playerlist.signal = function(player)
		if #Playerlist.connections == 0 then return end

		for _, connection in Playerlist.connections do
			TCall(connection)(player)
		end
	end

	Playerlist.functions.friendly = function()
		local index = Playerlist.table.default and #Playerlist.table.default.columns
		local column = Playerlist.table.default and Playerlist.table.default.columns[index]
		local player = Playerlist.default

		if not player or not Playerlist.table.default or column == "LocalPlayer" then return end

		if column == "Friendly" then
			Playerlist.table.default:Set("Text", index, "None")
			if not Library.Friends[player.Name] then return end

			Library.Friends[player.Name] = nil
		end

		if Find({"None", "Priority"}, column) then
			Playerlist.table.default:Set("Text", index, "Friendly")
			Library.Friends[player.Name] = player

			if not player or not Library.Priorities[player.Name] then return end

			Library.Priorities[player.Name] = nil
		end
	end

	Playerlist.functions.priority = function()
		local index = Playerlist.table.default and #Playerlist.table.default.columns
		local column = Playerlist.table.default and Playerlist.table.default.columns[index]
		local player = Playerlist.default

		if not player or not Playerlist.table.default or column == "LocalPlayer" or Find(Library.Ignore, player.UserId) then return end

		if column == "Priority" then
			Playerlist.table.default:Set("Text", index, "None")
			if not Library.Priorities[player.Name] then return end

			Library.Priorities[player.Name] = nil
		end

		if Find({"None", "Friendly"}, column) then
			Playerlist.table.default:Set("Text", index, "Priority")
			Library.Priorities[player.Name] = player

			if not player or not Library.Friends[player.Name] then return end

			Library.Friends[player.Name] = nil
		end
	end

	Playerlist.friendly:Connect(Playerlist.functions.friendly)
	Playerlist.priority:Connect(Playerlist.functions.priority)

	Playerlist.table:Connect(function(row)
		Playerlist.name = row and row.columns[1] or nil
		Playerlist.default = row and Players[Playerlist.name] or nil
		Playerlist.display_name = row and Playerlist.default.DisplayName or nil
		Playerlist.user_id = row and Playerlist.default.UserId or nil

		Playerlist.thumbnail = row and Players:GetUserThumbnailAsync(Playerlist.user_id, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size60x60) or nil
		Playerlist.health = row and Playerlist.default.Character.Humanoid.Health or nil

		Playerlist.description = row and Format("UserID: %s\nDisplayName: %s\nName: %s\nHealth: %s", 
			Playerlist.user_id, 
			Playerlist.display_name,
			Playerlist.name,
			Playerlist.health
		) or nil

		Playerlist.image:Set("ID", row and Playerlist.thumbnail or "")
		Playerlist.image:Set("Description", row and Playerlist.description or Playerlist.image.desc)

		Playerlist.signal(Playerlist.default)
		TCall(Playerlist.callback)(Playerlist.default)
	end)

	Library:Connection(Players.PlayerAdded, function(player)
		Playerlist:AddPlayer(player)
	end)

	Library:Connection(Players.PlayerRemoving, function(player)
		Playerlist:RemovePlayer(player)
	end)

	function Playerlist:AddPlayer(Player)
		Playerlist.players[Player.Name] = Playerlist.table:Row({Player.Name, Player == Players.LocalPlayer and "LocalPlayer" or "None"})
	end

	function Playerlist:RemovePlayer(Player)
		local row = Playerlist.players[Player.Name]

		if Library.Friends[Player.Name] then
			Library.Friends[Player.Name] = nil
		end

		if Library.Priorities[Player.Name] then
			Library.Priorities[Player.Name] = nil
		end

		if row then
			row:Remove()
		end
	end

	function Playerlist:GetPlayers()
		for _, player in Players:GetPlayers() do
			Playerlist.players[player.Name] = Playerlist.table:Row({player.Name, player == Players.LocalPlayer and "LocalPlayer" or "None"})
		end
	end

	Playerlist:GetPlayers()

	return Playerlist
end

--// Window / Tab / Section
function Library:Section(title, side)
	local Section = {
		title = title or "Section",
		side = (side or "left"):lower(),

		tab = self,
		functions = {},
		class = "section"
	}

	local Tab = self
	Section.tabside = Tab.class == "tab" and Tab.sectionholder[Section.side] or Tab.object

	Section.object, Section.instances = 
		Library.instances.section(Section.tabside, Section)

	return SetMeta(Section, Library)
end

--// Window / Tab / Section / Toggle
function Library:Toggle(info)
	info = Library:CaseInsensitive(info or {})

	local Toggle = {
		title = info.title or "Toggle",
		default = info.default ~= nil and info.default or false,
		cfg = not Find({info.cfg, info.config}, false),
		flag = info.flag or Library:IndexFlag(),
		callback = info.callback or info.call_back or function() end,

		class = "element",
		tab = self.tab,
		tabside = self.tabside,
		keybinds = {},
		functions = {},
		connections = {}
	}

	local Parent = self

	Toggle.object, Toggle.instances = 
		Library.instances.toggle(Parent.object, Toggle)

	Toggle.signal = function(default)
		if #Toggle.connections == 0 then return end

		for _, connection in Toggle.connections do
			TCall(connection)(default)
		end
	end

	Toggle.functions.default = function(bool)
		Toggle.default = bool == nil and not Toggle.default or bool

		Library:Tween(Toggle.instances.indicator_accent, {Duration = 0.15, Direction = "InOut"}, {BackgroundTransparency = Toggle.default and 0 or 1})
		Library:Tween(Toggle.instances.indicator, {Duration = 0.15, Direction = "InOut"}, {BackgroundTransparency = Toggle.default and 1 or 0})

		Toggle.default = Toggle.default
		Library.Flags[Toggle.flag] = Toggle.default
		TCall(Toggle.key)()

		Toggle.signal(Toggle.default)
		TCall(Toggle.callback)(Toggle.default)
	end

	Toggle.key = function()
		if Library:Length(Toggle.keybinds) == 0 then return end

		for flag, keybind in Toggle.keybinds do
			keybind.toggle = Toggle.default

			if keybind.ignore then continue end
			Library.Keybinds(flag, {
				default = keybind.default, 
				mode = keybind.mode, 
				keyname = keybind.keyname,
				toggle = keybind.toggle, 
				title = keybind.title
			})
		end
	end

	Library:Connection(Toggle.instances.indicator.InputEnded, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Toggle:Set("Default", not Toggle.default)
	end)

	Library.Flags[Toggle.flag] = Toggle.default
	Library.Configs[Toggle.flag] = Toggle.cfg and Toggle or nil

    Toggle.signal(Toggle.default)
    TCall(Toggle.callback)(Toggle.default)

	return SetMeta(Toggle, Library)
end

--// Window / Tab / Section / ( Keybind ) OR ( Toggle / Keybind )
function Library:Keybind(info)
	info = Library:CaseInsensitive(info or {})

	local Keybind = {
		title =  info.title or self.class == "element" and self.title or "Keybind",
		default = info.default or false,
		key = info.key or Enum.KeyCode.Unknown,
		mode = info.mode or "toggle",
		list = info.list == nil and true or info.list,
		ignore = info.ignore,
		cfg = not Find({info.cfg, info.config}, false),
		flag = info.flag or Library:IndexFlag(),
		callback = info.callback or info.call_back or function() end,

		tab = self.tab,
		toggle = self.default,
		class = "element",
		type = "KeyCode",
		tabside = self.tabside,
		parent = self,
		overflowing = false,
		binding = false,
		modes = {},
		functions = {},
		connections = {},
	}

	local Parent = Keybind.parent

	if Keybind.parent.keybinds then
		Keybind.parent.keybinds[Keybind.flag] = Keybind
	end

	Keybind.keyname = Library.keynames[Keybind.key.Name] or Keybind.key.Name

	Keybind.instances = 
		Library.instances.keybind(Parent.object, Keybind)

	Keybind.signal = function(info)
		if #Keybind.connections == 0 then return end

		for _, connection in Keybind.connections do
			TCall(connection)(info)
		end
	end

	Keybind.functions.title = function(str)
		Keybind.instances.value.Text = str
	end
	
	Keybind.functions.key = function(enum)
		enum = enum == nil and Enum.KeyCode.Unknown or Library:EnumString(enum)

		if enum.Name == "MouseMovement" then return end

		Keybind.toggle = Keybind.default and Keybind.parent.default

		Keybind.key = enum.Name == "Backspace" and Enum.KeyCode.Unknown or enum
		Keybind.type = tostring(Keybind.key.EnumType)
		Keybind.keyname = Library.keynames[Keybind.key.Name] or Keybind.key.Name

		Keybind.instances.value.Text = Keybind.keyname
		Library.Flags[Keybind.flag] = {default = Keybind.default, mode = Keybind.mode, key = Keybind.key}

		if not Keybind.list then
			Keybind.signal(Keybind.key)
			TCall(Keybind.callback)(Keybind.key)
		end

		if Keybind.ignore then return end
		Library.Keybinds(Keybind.flag, {
			default = Keybind.default, 
			mode = Keybind.mode, 
			keyname = Keybind.keyname, 
			toggle = Keybind.toggle, 
			title = Keybind.title
		})
	end

	Keybind.functions.bind = function(input)
		if Keybind.binding then
			Keybind:Set("Key", input.UserInputType.Name == "Keyboard" and input.KeyCode or input.UserInputType)
			Keybind.binding = false
			return 
		end

		if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end

		Keybind.binding = Library:IsMouseOverFrame(Keybind.instances.value)
		Keybind.instances.value.Text = Library:IsMouseOverFrame(Keybind.instances.value) and "..." or Keybind.keyname
		Keybind.instances.window.Visible = Keybind.instances.window.Visible and (Library:IsMouseOverFrame(Keybind.instances.value) or Library:IsMouseOverFrame(Keybind.instances.window))
	end
	
	if Keybind.list then
		Keybind.functions.mode = function(mode)
			if not Find({"always", "toggle", "hold"}, mode:lower()) then return end

			Keybind.mode = mode
			Keybind.default = mode == "always" and Keybind.keyname ~= "none"
			Keybind.toggle = Keybind.parent.default ~= nil and (Keybind.default and Keybind.parent.default) or nil

			Library.Flags[Keybind.flag] = {default = Keybind.default, mode = Keybind.mode, key = Keybind.key}

			for mode, inst in Keybind.modes do
				Library:Tween(inst.text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = mode == Keybind.mode and 1 or 0})
				Library:Tween(inst.text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = mode == Keybind.mode and 0 or 1})
			end

			if Keybind.ignore then return end

			Library.Keybinds(Keybind.flag, {
				default = Keybind.default, 
				mode = Keybind.mode, 
				keyname = Keybind.keyname, 
				toggle = Keybind.toggle, 
				title = Keybind.title
			})
		end

		Keybind.functions.default = function(bool)
			if Keybind.keyname == "none" then return end

			if Keybind.mode == "always" then Keybind.default = true return end

			if Keybind.mode == "toggle" then
				Keybind.default = bool or not Keybind.default
			end

			if Keybind.mode == "hold" and not Keybind.default then
				Keybind.default = true
			end

			Keybind.toggle = Keybind.parent.default ~= nil and (Keybind.default and Keybind.parent.default) or nil

			Library.Flags[Keybind.flag] = {default = Keybind.default, mode = Keybind.mode, key = Keybind.key}

			Keybind.signal(Library.Flags[Keybind.flag])
			TCall(Keybind.callback)(Library.Flags[Keybind.flag])

			if Keybind.ignore then return end
			
			Library.Keybinds(Keybind.flag, {
				default = Keybind.default, 
				mode = Keybind.mode, 
				keyname = Keybind.keyname,
				toggle = Keybind.toggle, 
				title = Keybind.title
			})
		end

		Library:Connection(UserInputService.InputChanged, function(input)
			if not Keybind.tab.active or not Keybind.list or input[Keybind.type] ~= Keybind.key or Keybind.key.Name == "Unknown" then return end

			Keybind:Set("Default")
		end)

		Library:Connection(Keybind.instances.key.InputBegan, function(input)
			if not Keybind.tab.active or not Find({"MouseButton2", "Touch"}, input.UserInputType.Name) or Keybind.instances.window.Visible then return end

			Keybind.instances.window.Visible = true
		end)

		Library:Connection(UserInputService.InputEnded, function(input)
			if not Keybind.tab.active or Keybind.mode ~= "hold" or (input[Keybind.type] ~= Keybind.key or Keybind.key == Enum.KeyCode.Unknown) then return end

			Keybind.default = false
			Keybind.toggle = Keybind.parent.default

			Library.Flags[Keybind.flag] = {default = Keybind.default, mode = Keybind.mode, key = Keybind.key}
			Keybind.signal(Library.Flags[Keybind.flag])

			if Keybind.ignore then return end
			Library.Keybinds(Keybind.flag, {
				default = Keybind.default, 
				mode = Keybind.mode, 
				keyname = Keybind.keyname,
				toggle = Keybind.toggle, 
				title = Keybind.title
			})
		end)

		Library:Connection(Keybind.tabside:GetPropertyChangedSignal("CanvasPosition"), function()
			Keybind.overflowing = Library:IsOverflowing(Keybind.instances.window, Keybind.tabside)

			if Keybind.overflowing and Keybind.instances.window.Visible then
				Keybind.instances.window.Visible = false
			end
		end)

		for mode, inst in Keybind.modes do
			Library:Connection(inst.text.InputBegan, function(input)
				if input.UserInputType.Name ~= "MouseButton1" then return end

				Keybind:Set("Mode", mode)
			end)
		end
	end

	Library:Connection(UserInputService.InputBegan, function(input)
		if Keybind.tab.active then 
			Keybind:Set("Bind", input)
		end

		if not Keybind.list then return end

		if input.UserInputType == Enum.UserInputType.MouseButton2 and not Library:IsMouseOverFrame(Keybind.instances.key) then 
			Keybind.instances.window.Visible = Keybind.instances.window.Visible and Library:IsMouseOverFrame(Keybind.instances.window)
		end

		if input[Keybind.type] ~= Keybind.key or Keybind.key.Name == "Unknown" then return end

		Keybind:Set("Default")
	end)

	Library.Flags[Keybind.flag] = {default = Keybind.default, mode = Keybind.mode, key = Keybind.key}
	Library.Configs[Keybind.flag] = Keybind.cfg and Keybind or nil
	
    Keybind.signal(Library.Flags[Keybind.flag])
    TCall(Keybind.callback)(Library.Flags[Keybind.flag])

	if not Keybind.ignore then
		Library.Keybinds(Keybind.flag, {
			default = Keybind.default, 
			mode = Keybind.mode, 
			keyname = Keybind.keyname, 
			toggle = Keybind.toggle, 
			title = Keybind.title
		})
	end

	return SetMeta(Keybind, Library)
end

--// Window / Tab / Section / ( Colorpicker ) OR ( Toggle / Colorpicker )
function Library:Colorpicker(info)
	info = Library:CaseInsensitive(info or {})

	local Colorpicker = {
		title = info.title or "Colorpicker",
		default = info.default or Rgb(255, 0, 0), 
		alpha = info.alpha,
		cfg = not Find({info.cfg, info.config}, false),
		flag = info.flag or Library:IndexFlag(),
		callback = info.callback or info.call_back or function() end,

		drag = {},
		functions = {},
		parent = self,
		tabside = self.tabside,
		overflowing = false,
		class = "element",
		connections = {},
	}

	local Parent = self

	Colorpicker.instances = 
		Library.instances.colorpicker(Parent.object, Colorpicker)

	Colorpicker.signal = function(rgb, a)
		if #Colorpicker.connections == 0 then return end

		for _, connection in Colorpicker.connections do
			TCall(connection)(rgb, a)
		end
	end

	Colorpicker.functions.default = function(default, alpha)
		Colorpicker.hsv = default and Library:RGBToHSV(default) or {h = Colorpicker.h, s = Colorpicker.s, v = Colorpicker.v}
		Colorpicker.alpha = alpha or Colorpicker.alpha

		Colorpicker.hue = Clamp(Colorpicker.hsv.h, 0, 1)
		Colorpicker.sat = Clamp(Colorpicker.hsv.s, 0, 1)
		Colorpicker.val = Clamp(Colorpicker.hsv.v, 0, 1)
		Colorpicker.alpha = Colorpicker.alpha and Clamp(Colorpicker.alpha, 0, 1)

		Colorpicker.default = Hsv(Colorpicker.hue, 1 - Colorpicker.sat, 1 - Colorpicker.val)

		Colorpicker.instances.colorbutton.BackgroundTransparency = Colorpicker.alpha and (1 - Colorpicker.alpha) or 0
		Colorpicker.instances.colorbutton.BackgroundColor3 = Colorpicker.default
		Colorpicker.instances.color.BackgroundColor3 = Hsv(Colorpicker.hue, 1, 1)
		Colorpicker.instances.alpha.BackgroundColor3 = Hsv(Colorpicker.hue, 1, 1)
		Colorpicker.instances.text_content.Text = Concat({
			Library:Round(Colorpicker.default.R * 255, 1), 
			Library:Round(Colorpicker.default.G * 255, 1), 
			Library:Round(Colorpicker.default.B * 255, 1), 
			Colorpicker.alpha and Library:Round(Colorpicker.alpha, .01)
		}, ", ")

		Library:Tween(Colorpicker.instances.hue_pointer, {Duration = .15}, {Position = Dim2(0, 0, Colorpicker.hue, 0)})
		Library:Tween(Colorpicker.instances.satval_pointer, {Duration = .15}, {Position = Dim2(Colorpicker.sat, 0, Colorpicker.val, 0)})
		Library:Tween(Colorpicker.instances.alpha_pointer, {Duration = .15}, {Position = Dim2(Colorpicker.alpha, 0, 0, 0)})

		if Colorpicker.default == Colorpicker.oldrgb and Colorpicker.alpha == Colorpicker.oldalpha then return end

		Colorpicker.oldhsv = Colorpicker.hsv
		Colorpicker.oldalpha = Colorpicker.alpha or 1
		Colorpicker.oldrgb = Colorpicker.default
		Library.Flags[Colorpicker.flag] = {default = Colorpicker.default, alpha = Colorpicker.alpha}

		Colorpicker.signal(Colorpicker.default, Colorpicker.alpha)
		TCall(Colorpicker.callback)(Colorpicker.default, Colorpicker.alpha)
	end

	Library:Connection(UserInputService.InputBegan, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) or Library:IsOverflowing(Colorpicker.instances.window, Colorpicker.tabside) then return end
		if Library:IsMouseOverFrame(Colorpicker.instances.colorbutton) then return end

		Colorpicker.instances.window.Visible = Colorpicker.instances.window.Visible and Library:IsMouseOverFrame(Colorpicker.instances.window)
	end)

	Library:Connection(Colorpicker.instances.colorbutton.InputBegan, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) or Colorpicker.instances.window.Visible then return end

		Colorpicker.instances.window.Visible = true
	end)

	Library:Connection(Colorpicker.tabside:GetPropertyChangedSignal("CanvasPosition"), function()
		Colorpicker.overflowing = Library:IsOverflowing(Colorpicker.instances.window, Colorpicker.tabside)

		if Colorpicker.overflowing and Colorpicker.instances.window.Visible then
			Colorpicker.instances.window.Visible = false
		end
	end)

	Library:Connection(Colorpicker.instances.text_content.FocusLost, function(entered)
		if not entered then return end

		if Colorpicker.instances.text_content.Text:match("%a") then 
			Colorpicker.instances.text_content.Text = `{Colorpicker.default.rgb.R * 255}, {Colorpicker.default.rgb.G * 255}, {Colorpicker.default.rgb.B * 255}`
			return
		end

		entered = Colorpicker.instances.text_content.Text:gsub(" ",""):split(",")

		if Colorpicker.alpha and #entered == 4 then
			Colorpicker:Set("Default", Rgb(entered[1], entered[2], entered[3]), entered[4])
			return
		end

		Colorpicker:Set("Default", Rgb(entered[1], entered[2], entered[3]))
	end)

	Library:Connection(UserInputService.InputChanged, function(input)
		if input.UserInputType.Name ~= "MouseMovement" then return end

		for index, bool in Colorpicker.drag do
			if not bool then continue end
			Colorpicker:Set(index, input)
		end
	end)

	--[[ alpha ]] if Colorpicker.alpha then
		Colorpicker.functions.alpha = function(input)
			Colorpicker.alpha = (input.Position.X - Colorpicker.instances.alpha.AbsolutePosition.X) / Colorpicker.instances.alpha.AbsoluteSize.X
			Colorpicker.h = Colorpicker.oldhsv.h
			Colorpicker.s = Colorpicker.oldhsv.s
			Colorpicker.v = Colorpicker.oldhsv.v

			Colorpicker:Set("Default")
		end

		Library:Connection(Colorpicker.instances.grid.InputBegan, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Colorpicker.drag.alpha = true
			Colorpicker:Set("alpha", input)
		end)

		Library:Connection(Colorpicker.instances.grid.InputEnded, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Colorpicker.drag.alpha = false
		end)
	end

	--[[ SatVal ]] do
		Colorpicker.functions.satval = function(input)
			Colorpicker.alpha = Colorpicker.alpha and Colorpicker.oldalpha
			Colorpicker.h = Colorpicker.oldhsv.h
			Colorpicker.s = (input.Position.X - Colorpicker.instances.color.AbsolutePosition.X) / Colorpicker.instances.color.AbsoluteSize.X
			Colorpicker.v = (input.Position.Y - Colorpicker.instances.color.AbsolutePosition.Y) / Colorpicker.instances.color.AbsoluteSize.Y

			Colorpicker:Set("Default")
		end

		Library:Connection(Colorpicker.instances.color.InputBegan, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end
			Colorpicker.drag.SatVal = true
			Colorpicker:Set("SatVal", input)
		end)

		Library:Connection(Colorpicker.instances.color.InputEnded, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Colorpicker.drag.SatVal = false
		end)
	end

	--[[ hue ]] do
		Colorpicker.functions.hue = function(input)
			Colorpicker.alpha = Colorpicker.alpha and Colorpicker.oldalpha
			Colorpicker.h = (input.Position.Y - Colorpicker.instances.hue.AbsolutePosition.Y) / Colorpicker.instances.hue.AbsoluteSize.Y
			Colorpicker.s = Colorpicker.oldhsv.s
			Colorpicker.v = Colorpicker.oldhsv.v

			Colorpicker:Set("Default")
		end

		Library:Connection(Colorpicker.instances.hue.InputBegan, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Colorpicker.drag.hue = true
			Colorpicker:Set("hue", input)
		end)

		Library:Connection(Colorpicker.instances.hue.InputEnded, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Colorpicker.drag.hue = false
		end)
	end

	Colorpicker.hsv = Library:RGBToHSV(Colorpicker.default)
	Colorpicker.oldhsv = Colorpicker.hsv
	Colorpicker.oldrgb = Colorpicker.default
	Colorpicker.oldalpha = Colorpicker.alpha or 1

	Library.Flags[Colorpicker.flag] = {default = Colorpicker.default, alpha = Colorpicker.alpha}
	Library.Configs[Colorpicker.flag] = Colorpicker.cfg and Colorpicker or nil

    Colorpicker.signal(Colorpicker.default, Colorpicker.alpha)
    TCall(Colorpicker.callback)(Colorpicker.default, Colorpicker.alpha)

	return SetMeta(Colorpicker, Library)
end

--// Window / Tab / Section / Slider
function Library:Slider(info)
	info = Library:CaseInsensitive(info or {})

	local Slider = {
		title = info.title or "Slider",
		indicator = info.indicator or false,
		min = info.min or info.minimum or 0,
		default = info.default or 50,
		max = info.max or info.maximum or 100,
		float = info.float or 0.01,
		cfg = not Find({info.cfg, info.config}, false),
		flag = info.flag or Library:IndexFlag(),
		callback = info.callback or info.call_back or function() end,
		
		functions = {},
		Sliding = false,
		class = "element",
		connections = {},
	}

	local Parent = self

	Slider.olddefault = Clamp(Library:Round(Slider.default, Slider.float), Slider.min, Slider.max)

	Slider.oldmin = Library:Round(Slider.min, 1)
	Slider.oldmax = Library:Round(Slider.max, 1)

	Slider.instances = 
		Library.instances.slider(Parent.object, Slider)

	Slider.signal = function(player)
		if #Slider.connections == 0 then return end

		for _, connection in Slider.connections do
			TCall(connection)(player)
		end
	end

	Slider.functions.visible = function(bool)
		Slider.instances.slider.Visible = bool == nil and not Slider.instances.slider.Visible or bool
	end

	Slider.functions.min = function(num)
		if num == Slider.oldmin then return end

		Slider.min = num and Library:Round(num, 1) or Slider.min
		Slider:Set("Default", ((Slider.max - Slider.min) * Slider.default) + Slider.min)
	end

	Slider.functions.max = function(num)
		if num == Slider.oldmax then return end

		Slider.max = num and Library:Round(num, 1) or Slider.max
		Slider.instances.value.Text = `{ Slider.default }/{ Slider.max }`

		Slider:Set("Default", ((Slider.max - Slider.min) * Slider.default) + Slider.min)
	end

	Slider.functions.default = function(default)
		default = Clamp(Library:Round(default, Slider.float), Slider.min, Slider.max)

		default = default == -0 and 0 or default

		if default == Slider.olddefault then return end

		Slider.instances.value.Text = `{ default }/{ Slider.max }`
		Slider.default = default

		Slider.Size = Dim2((default - Slider.min) / (Slider.max - Slider.min), 0, 1, 0)
		Library:Tween(Slider.instances.indicator, {Duration = 0.1}, {Size = Slider.Size})

		Slider.olddefault = default
		Library.Flags[Slider.flag] = Slider.default

		Slider.signal(default)
		TCall(Slider.callback)(Slider.default)
	end

	if not Slider.indicator then
		Slider.functions.input = function(input)
			local sizeX = (input.Position.X - Slider.instances.realslider.AbsolutePosition.X) / Slider.instances.realslider.AbsoluteSize.X

			Slider:Set("Default", ((Slider.max - Slider.min) * sizeX) + Slider.min)
		end

		Library:Connection(Slider.instances.realslider.InputBegan, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Slider.Sliding = true
			Slider:Set("Input", input)
		end)

		Library:Connection(Slider.instances.realslider.InputEnded, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Slider.Sliding = false
		end)

		Library:Connection(UserInputService.InputChanged, function(input)
			if not Find({"MouseMovement", "Touch"}, input.UserInputType.Name) or not Slider.Sliding then return end

			Slider:Set("Input", input)
		end)
	end

	Library.Flags[Slider.flag] = Slider.default
	Library.Configs[Slider.flag] = Slider.cfg and Slider or nil

    Slider.signal(default)
    TCall(Slider.callback)(Slider.default)

	return SetMeta(Slider, Library)
end

--// Window / Tab / Section / Dropdown
function Library:Dropdown(info)
	info = Library:CaseInsensitive(info or {})

	local Dropdown = {
		title = info.title or "dropdown",
		options = info.options or {1, 2, 3},
		default = info.default,
		flag = info.flag or Library:IndexFlag(),
		multi = info.multi,
		cfg = not Find({info.cfg, info.config}, false),
		callback = info.callback or info.call_back or function() end,

		class = "element",
		values = {},
		functions = {},
		connections = {}
	}

	Dropdown.default = Dropdown.default or Dropdown.options[1]

	SetMeta(Dropdown, Library)

	local Parent = self

	Dropdown.object, Dropdown.instances = 
		Library.instances.dropdown(Parent.object, Dropdown)

	Dropdown.signal = function(default)
		if #Dropdown.connections == 0 then return end

		for _, connection in Dropdown.connections do
			TCall(connection)(default)
		end
	end

	Dropdown.functions.default = function(options)
		options = type(options) ~= "table" and {options} or options

		for _, value in Dropdown.options do
			Dropdown.values[value]:Set("Default", value == options)
		end
	end

	function Dropdown:Remove(options)
		Dropdown.values[options]:Remove()
	end

	function Dropdown:Refresh(options)
		for _, value in Dropdown.values do
			value:Remove()
		end

		Dropdown.options = options or Dropdown.options
		for _, value in Dropdown.options do
			Dropdown:Option(value)
		end
	end

	for _, option in Dropdown.options do
		Dropdown:Option(option)
	end

	Library:Connection(Dropdown.instances.realdropdown.InputBegan, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Dropdown.instances.optionholder.Visible = not Dropdown.instances.optionholder.Visible and Library:IsMouseOverFrame(Dropdown.instances.realdropdown) or Library:IsMouseOverFrame(Dropdown.instances.optionholder) 
	end)

	Library.Flags[Dropdown.flag] = Dropdown.default
	Library.Configs[Dropdown.flag] = Dropdown.cfg and Dropdown or nil

    Dropdown.signal(Dropdown.default)
    TCall(Dropdown.callback)(Dropdown.default)

	return Dropdown
end

--// Window / Tab / Section / List
function Library:List(info)
	info = Library:CaseInsensitive(info or {})

	local List = {
		title = info.title or "List",
		height = info.height or 100,
		options = info.options or {"Cfg1", "Cfg2", "Cfg3"},
		default = info.default,
		flag = info.flag or Library:IndexFlag(),
		cfg = not Find({info.cfg, info.config}, false),
		callback = info.callback or info.call_back or function() end,
		multi = info.multi,

		class = "element",
		searching = false,
		values = {},
		functions = {},
		connections = {},
	}

	List.default = List.default or List.options[1]

	SetMeta(List, Library)

	local Parent = self

	List.content, List.object, List.instances = 
		Library.instances.list(Parent.object, List)

	List.signal = function(info)
		if #List.connections == 0 then return end

		for _, connection in List.connections do
			TCall(connection)(info)
		end
	end

	List.functions.default = function(options)
		options = type(options) ~= "table" and {options} or options

		for _, value in List.options do
			List.values[value]:Set("Default", value == options)
		end
	end

	function List:Search(query)
		for _, option in List.values do
			local str = Lower(option.title)
			
			option:Set("Visible", string.find(str, Lower(query)) ~= nil) 
		end
	end

	function List:Remove(options)
		List.values[options]:Remove()
	end

	function List:Refresh(options)
		for _, value in List.values do
			value:Remove()
		end

		List.options = options or List.options
		for _, value in List.options do
			List:Option(value)
		end
	end

	for _, option in List.options do
		List:Option(option)
	end

	Library:Connection(List.instances.text:GetPropertyChangedSignal("Text"), function()
		List:Search(List.instances.text.Text)
	
		List.searching = #List.instances.text.Text ~= 0
	end)

	Library.Flags[List.flag] = List.default
	Library.Configs[List.flag] = List.cfg and List or nil

    List.signal(List.default)
    TCall(List.callback)(List.default)

	return SetMeta(List, Library)
end

--// Window / Tab / Section / ( Dropdown / Option ) OR ( List / Option )
function Library:Option(value)
	local Parent = self

	local Option = {
		active = Parent.default == value, 
		title = value,

		class = "sub-element",
		functions = {},
	}
	
	SetMeta(Option, Library)
	
	if not Option.title then return end

	if not Find(Parent.options, Option.title) then Insert(Parent.options, Option.title) end	

	Option.instances = 
		Library.instances.option(Parent.object, Option)

	Option.functions.default = function(bool)
		if Parent.multi then 
			Parent.default = type(Parent.default) == "table" and Parent.default or {Parent.default}

			local index = Find(Parent.default, Option.title)

			if index then
				Remove(Parent.default, index)
			end

			Option.active = bool ~= nil and bool or index == nil

			Library:Tween(Option.instances.text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = Option.active and 1 or 0})
			Library:Tween(Option.instances.text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = Option.active and 0 or 1})

			if Option.active then
				Insert(Parent.default, Option.title)
			end

			Library.Flags[Parent.flag] = Parent.default
			Parent.signal(Parent.default)
            TCall(Parent.callback)(Parent.default)

			if Parent.instances.value then
				Parent.instances.value.Text = Library:Length(Parent.default) > 0 and Concat(Parent.default, ", ") or "none"
			end

			return
		end

		Parent.default = Option.title

		for _, val in Parent.values do
			val.active = val == Parent.values[Parent.default]

			Library:Tween(val.instances.text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = val.active and 1 or 0})
			Library:Tween(val.instances.text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = val.active and 0 or 1})
		end

		if Parent.instances.value then
			Parent.instances.value.Text = Parent.default
		end

		Library.Flags[Parent.flag] = Parent.default
		Parent.signal(Parent.default)

		TCall(Parent.callback)(Parent.default)
	end

	function Option:Remove(value)
		if not Option.instances then return end

		if Option.multi then 
			local index = Find(Parent.default, Option.title)
			if index then
				Remove(Option.default, index)
			end

			if Parent.instances.value then
				Parent.instances.value.Text = Library:Length(Parent.default) > 0 and Concat(Parent.default, ", ") or "none"
			end

			local index = Find(Parent.options, Option.title)
			if index then Remove(Parent.options, index) end

			Option.instances.option:Destroy()

			if Parent.values[Option.title] then 
				Parent.values[Option.title] = nil 
			end

			return 
		end

		local index = Find(Parent.options, Option.title)
		if index then Remove(Parent.options, index) end

		if Parent.default == value then
			Parent:Set("Default", Parent.options[#Parent.options + (index >= #Parent.options and -1 or 1)])
		end

		Option.instances.option:Destroy()

		if Parent.values[Option.title] then 
			Parent.values[Option.title] = nil 
		end
	end

	Parent.Lists = Parent.Lists or function()
		return Parent.values
	end

	Option.functions.visible = function(bool)
		Option.instances.option.Visible = bool == nil and not Option.instances.option.Visible or bool
	end

	Library:Connection(Option.instances.option.InputBegan, function(input)
		if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Option:Set("Default")
	end)
	
	Option:Set("Visible", not Parent.searching)
	
	Parent.values[Option.title] = Option

	return Option
end

--// Window / Tab / Section / Table
function Library:Table(info)
	info = Library:CaseInsensitive(info or {})

	local Table = {
		flag = info.flag or Library:IndexFlag(),
		height = info.height or 146,
		headers = info.headers or {"Names", "Info"},
		keyword = info.keyword or {localplayer = Rgb(73, 115, 255), friendly = Rgb(73, 255, 115), priority = Rgb(255, 73, 73)},
		cfg = not Find({info.cfg, info.config}, false),
		callback = info.callback or info.call_back or function() end,

		rows = {},
		functions = {},
		connections = {},
		class = "element",
		searching = false,
	}

	SetMeta(Table, Library)

	local Parent = self

	Table.table, Table.object, Table.instances = 
		Library.instances.list(Parent.object, Table)

	Table.signal = function(default)
		if #Table.connections == 0 then return end

		for _, connection in Table.connections do
			TCall(connection)(default)
		end
	end

	Table.functions.default = function(row)
		row:Set("Default")
		Table.default = row
	end

	function Table:GetRow(Index)
		if #Table.rows < Index then return end

		return Table.rows[Index]
	end

	function Table:GetIndex(Row)
		return Find(Table.rows, Row)
	end

	function Table:Search(query, index)
		for _, row in Table.rows do
			row:Set("Visible", string.find(Lower(row.columns[index]), Lower(query)) ~= nil) 
		end
	end

	Table:Row(Table.headers, true)
	Table.default = nil
	Library.Configs[Table.flag] = Table.cfg and Table or nil

	return SetMeta(Table, Library)
end

--// Window / Tab / Section / Table / Row
function Library:Row(value, header)
	local Row = {
		columns = value,
		rawvalue = Concat(value, "-"),
		header = header,

		functions = {},
		keyword = self.keyword,
		headers = self.headers,
		texts = {},
		values = {},
		class = "sub-element",
	}
	
	SetMeta(Row, Library)
	
	local Parent = self

	Row.active = Parent.rows[2] == Row

	Row.instances = 
		Library.instances.row(Parent[Row.header and "table" or "object"], Row)

	Row.functions.default = function()
		Parent.default = Parent.default ~= Row and Row

		for _, row in Parent.rows do
			row.active = row == Row and not row.active or row ~= Row and false

			Library:Tween(row.texts[1].text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = row.active and 1 or 0})
			Library:Tween(row.texts[1].text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = row.active and 0 or 1})
		end

		Library.Flags[Parent.flag] = Parent.default
		Parent.signal(Parent.default)
		TCall(Parent.callback)(Parent.default)
	end

	Row.functions.visible = function(bool)
		Row.instances.row.Visible = bool == nil and not Row.instances.row.Visible or bool
	end

	Row.functions.text = function(index, str)
		if index > #Row.texts then return end

		Row.columns[index] = str
		Row.texts[index].text.Text = str
		Row.texts[index].text.Text = str
		Row.rawvalue = Concat(Row.columns, "-")

		Library:Tween(Row.texts[index].text, {Duration = .15}, {TextColor3 = Row.keyword[str:lower()] or Library.instances.theme["RowTextColor"]})
	end

	function Row:Remove()
		local index = Find(Parent.rows, Row)
		if index then Remove(Parent.rows, Row) end

		if Parent.default == Row then
			Parent.default = nil
		end

		for _, instance in Row.instances do
			instance:Destroy()
		end
	end

	if Row.header then
		for index, header in Parent.headers do
			Library:Connection(Row.values[header].text:GetPropertyChangedSignal("Text"), function()
				Parent:Search(Row.values[header].text.Text, index)
				
				Parent.searching = #Row.values[header].text.Text ~= 0
			end)
		end
	else
		Library:Connection(Row.instances.row.InputBegan, function(input)
			if not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

			Row:Set("Default")
		end)

		Parent.rows[Row.rawvalue] = Row
	end
	
	Row:Set("Visible", not Parent.searching)
	
	return Row
end

--// Window / Tab / Section / Table / Textbox
function Library:Textbox(info)
	info = Library:CaseInsensitive(info or {})

	local Textbox = {
		title = info.title or "textbox",
		placeholder = info.placeholder or info.place_holder or "...",
		cleartext = info.cleartext or info.clear_text or false,
		cfg = not Find({info.cfg, info.config}, false),
		flag = info.flag or Library:IndexFlag(),
		callback = info.callback or info.call_back or function() end,

		class = "element",
		functions = {},
		connections = {},
	}

	local Parent = self

	Textbox.instances = 
		Library.instances.textbox(Parent.object, Textbox)

	Textbox.signal = function(player)
		if #Textbox.connections == 0 then return end

		for _, connection in Textbox.connections do
			TCall(connection)(player)
		end
	end

	Library:Connection(Textbox.instances.text:GetPropertyChangedSignal("Text"), function()
		Textbox:Set("Default", Textbox.instances.text.Text)

		Textbox.signal(Textbox.default)
		TCall(Textbox.callback)(Textbox.default)
	end)

	Textbox.functions.default = function(str)
		Textbox.instances.text.Text = str

		Textbox.default = str
		Library.Flags[Textbox.flag] = str
	end

	Textbox.functions.placeholder = function(str)
		Textbox.instances.text.PlaceholderText = str
	end

	Textbox.default = info.title
	Library.Flags[Textbox.flag] = Textbox.title
	Library.Configs[Textbox.flag] = Textbox.cfg and Textbox or nil

	return SetMeta(Textbox, Library)
end

--// Window / Tab / Section / ( Button ) OR ( Button / Button ) OR ( Image / Button )
function Library:Button(info)
	info = Library:CaseInsensitive(info or {})

	local Button = {
		title = info.title or "Button",
		debouncetime = info.debouncetime or info.debounce_time,
		flag = info.flag or Library:IndexFlag(),
		callback = info.callback or info.call_back or function() end,

		parent = self,
		class = "element",
		functions = {},
		connections = {}
	}

	local Parent = self

	Button.object, Button.instances = 
		Library.instances.button(Parent.object, Button)

	Button.signal = function(bool)
		if #Button.connections == 0 then return end

		for _, connection in Button.connections do
			TCall(connection)(bool)
		end
	end

	Button.animation = function(dur)
		Library:Tween(Button.instances.text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = 1})
		Library:Tween(Button.instances.text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = 0})

		Wait_(dur and dur >= .15 and dur or .15)

		Library:Tween(Button.instances.text, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = 0})
		Library:Tween(Button.instances.text_accent, {Duration = 0.15, Direction = "InOut"}, {TextTransparency = 1})
	end

	Button.functions.title = function(str)
		Button.instances.text = str
	end

	Button.functions.active = function(bool)
		TCall(Button.animation)(Button.debouncetime)

		Button.default = true
		Library.Flags[Button.flag] = true
		Button.signal(true)
		TCall(Button.callback)(true)

		if Button.debouncetime then
			Wait_(Button.debouncetime)
		end

		Button.default = false
		Library.Flags[Button.flag] = false
	end

	Library:Connection(Button.instances.button.InputEnded, function(input)
		if Library.Flags[Button.flag] or not Find({"MouseButton1", "Touch"}, input.UserInputType.Name) then return end

		Button:Set("Active", true)
	end)

	Button.default = false
	Library.Flags[Button.flag] = false

	return SetMeta(Button, Library)
end

--// Window / Tab / Section / Label
function Library:Label(info)
	info = Library:CaseInsensitive(info or {})

	local Label = {
		title = info.title or "Label",
		alignment = info.alignment or "left",
		paragraph = info.paragraph ~= nil,
		cfg = not Find({info.cfg, info.config}, false),
		flag = info.flag or Library:IndexFlag(),

		functions = {},
		class = "element",
	}

	local Parent = self

	Label.object, Label.instances = 
		Library.instances.label(Parent.object, Label)

	Label.functions.title = function(str)
		Label.instances.text.Text = str
		Label.default = str
		Library.Flags[Label.flag] = str
	end

	Label.functions.visible = function(bool)
		Label.instances.text.Visible = bool == nil and not Label.instances.text.Visible or bool
	end

	Label.default = Label.title
	Library.Flags[Label.flag] = Label.title
	Library.Configs[Label.flag] = Label.cfg and Label or nil

	return SetMeta(Label, Library)  
end

--// Window / Tab / Section / Divider
function Library:Divider(info)
	info = Library:CaseInsensitive(info or {})

	local Divider = {
		title = info.title or "Divider",
		flag = info.flag or Library:IndexFlag(),

		class = "element",
		functions = {},
	}

	local Parent = self

	Divider.instances = 
		Library.instances.divider(Parent.object, Divider)

	Divider.functions.title = function(str)
		Library.instances.text = str
		Divider.default = str
		Library.Flags[Divider.flag] = str
	end

	return Divider 
end

--// Window / Tab / Section / Image
function Library:Image(info)
	info = Library:CaseInsensitive(info or {})

	local Image = {
		id = info.id or "rbxassetid://0",
		desc = info.desc or info.description or "Actyrn Loves Childrens",
		flag = info.flag or Library:IndexFlag(),

		functions = {},
		class = "element",
	}

	SetMeta(Image, Library)

	local Parent = self

	Image.object, Image.instances = 
		Library.instances.image(Parent.object, Image)

	Image.functions.id = function(id)
		Image.instances.realimage.Image = id
	end

	Image.functions.description = function(id)
		Image.instances.text.Text = id
	end

	return SetMeta(Image, Library)
end

--// Window / Tab / Configuration
function Library:Configuration(title, side)
	local Config = {
		title = title or "Config",
		side = (side or "left"):lower(),

		class = "presets"
	}

	local Tab = self

	Config.Section = Tab:Section(Config.title, Config.side)
	Config.List = Config.Section:List({flag = Library:Random(), cfg = false, options = Library:ListConfigs(), title = "Search..."})
	Config.Refresh = Config.Section:Button({flag = Library:Random(), cfg = false, title = "Refresh"})

	Config.Name = Config.Section:Textbox({flag = Library:Random(), cfg = false, title = "", placeholder = "File Name", cleartext = true})
	Config.Rename = Config.Section:Button({flag = Library:Random(), cfg = false, title = "Rename"})

	Config.Load = Config.Section:Button({flag = Library:Random(), cfg = false, title = "Load"})
	Config.Save = Config.Load:Button({flag = Library:Random(), cfg = false, title = "Save"})
	Config.Delete = Config.Section:Button({flag = Library:Random(), cfg = false, title = "Delete"})

	Config.List:Connect(function(default)
        if not default or #default == 0 then return end

		Config.Name:Set("Title", default)
	end)

	Config.Refresh:Connect(function(...)
		Config.List:Refresh(Library:ListConfigs()) 
	end)

	Config.Rename:Connect(function()
        local CfgPath = `{ Library.Folders.Configs }{ Library.Folders.Prefix }{ Config.List.default }`
		local CfgFile = isfile(CfgPath) and readfile(CfgPath)

		if #Config.Name.default == 0 or not CfgFile then return end

		delfile(CfgPath)
		writefile(`{ Library.Folders.Configs }{ Library.Folders.Prefix }{ Config.Name.default }.{ Library.Folders.Format }`, CfgFile)
		Config.List:Refresh(Library:ListConfigs()) 
	end)

	Config.Load:Connect(function()
        if not Config.List.default then return end

		Library:LoadConfig(Config.List.default) 
	end)

	Config.Save:Connect(function()
		local ConfigName = #Config.Name.default ~= 0 and Config.Name.default or Config.List.default

		if not ConfigName then return end

		Library:SaveConfig(ConfigName) 
		Config.List:Refresh(Library:ListConfigs()) 
	end)

	Config.Delete:Connect(function()
		if not Config.List.default then return end

		delfile(Config.List.default)
		Config.List:Refresh(Library:ListConfigs()) 
	end)

	return Config
end

--// Window / Tab / Configuration
function Library:Font(title, side)
	local Font_ = {
		title = title or "Fonts",
		side = (side or "left"):lower(),

		class = "presets"
	}

	local Tab = self
	
	Font_.Section = Tab:Section(Font_.title, Font_.side)
	
	Font_.List = Font_.Section:List({options = Library:Keys(Library.Fonts), default = "Proggy", title = "Search...", callback = function(font)
		if not font then return end
		Library:SetFont(Library.Fonts[font])
	end})
	
	Font_.Refresh = Font_.Section:Button({title = "Refresh", callback = function()
		Font_.List:Refresh(Library:Keys(Library.Fonts)) 
	end})
	
	Font_.Size = Font_.Section:Slider({title = "Text Size", float = 1, default = Library.instances.textsize, max = 25, min = 5, callback = function(value)
		Library:SetTextSize(value)
	end})
	
	return Font_
end

--// Window / Tab / Themes
function Library:Themes(title, side)
	local Theme = {
		title = title or "Themes",
		side = (side or "left"):lower(),

		class = "presets"
	}

	local Tab = self

	Theme.Section = Tab:Section(Theme.title, Theme.side)
	for key , v in Library.instances.theme do
		Theme[key] = Theme.Section:Colorpicker({
			flag = Library:Random(), cfg = false,
			Title = key,
			Default = v,
		})

		Theme[key]:Connect(function(color) 
			Library:SetTheme(key, color) 
		end)
	end

	local ResetTheme = Theme.Section:Button({Title = "Reset"})

	ResetTheme:Connect(function()
		for key , value in Library.instances.defaulttheme do
			Theme[key]:Set("default", value)
		end
	end)

	return Theme
end

--// Notifications
function Library:Notifications(open)
	local Notifications = {
		open = open == nil and true or open,
		element = {},
		signal = {},
		functions = {},
		class = "notifications",
	}

	SetMeta(Notifications, Library)

	Notifications.object, Notifications.instances = 
		Library.instances.notification_list(Library.notifs, Notifications)

	function Notifications:Send(info)
		info = Library:CaseInsensitive(info or {})

		local Message = {
			title = info.title or "[Azure Modded] Loaded in %ss...",
			value = info.value,
			duration = info.duration or 1,

			functions = {},
			class = "sub-window",
		}

		Message.title = Message.value and Format(Message.title, Message.value) or Message.title

		Message.instances = 
			Library.instances.notification(Notifications.object, Message)

		Message.play = TCall(function()
			Library:Tween(Message.instances.realnotification, {Duration = .8}, {GroupTransparency = 0, Position = Dim2(0, 0, 0, 3)}, .8 + Message.duration)
			Library:Tween(Message.instances.notification, {Duration = .4, DelayTime = .3}, {Size = Dim2(0, 0, 0, 0)})
			Library:Tween(Message.instances.stroke, {Duration = .8}, {Transparency = 1})
			Library:Tween(Message.instances.realnotification, {Duration = .8}, {GroupTransparency = 1, Position = Dim2(0, -(Message.instances.realnotification.AbsoluteSize.X + Message.instances.realnotification.AbsolutePosition.X), 0, 3)}, .8)
			Message.instances.notification:Destroy()
		end)

		Message.play()

		return Notifications
	end

	Notifications.functions.visible = function(bool)
		Notifications.open = bool == nil and not Notifications.open or bool
		Notifications.instances.sub_window.Visible = Notifications.open
	end

	Notifications.functions.position = function(dim2)
		Library:Tween(Notifications.instances.sub_window, {}, {Position = dim2})
	end

	return Notifications
end

--// Keybind list
function Library:Keybindlist(info)
	info = Library:CaseInsensitive(info or {})

	local Keybindlist = {
		title = info.title or "Keybind List",
		open = info.open ~= nil and info.open or false,

		position = info.position or Vector2.new(3, Library.framework.AbsoluteSize.Y / 2),

		width = info.width or 250,
		height = info.height or 25,

		minwidth = info.minwidth or 100,
		minheight = info.minwidth or 25,

		maxwidth = info.maxwidth or 250,
		maxheight = info.maxheight or 25,

		element = {},
		signal = {},
		functions = {},
		class = "sub-window",
	}

	Keybindlist.object, Keybindlist.instances = 
		Library.instances.sub_window(Library.hud, Keybindlist)

	SetMeta(Keybindlist, Library)

	function Keybindlist:RegisterKeybind(flag, value, bool)
		if Keybindlist.element[flag] then
			Keybindlist.element[flag]:Set("Visible", bool)
			Keybindlist.element[flag].value:Set("Title", `{value.mode} [{value.keyname}]`)

			return
		end

		Keybindlist.element[flag] = Keybindlist:Label({flag = Library:Random(), cfg = false, Title = value.title})
		Keybindlist.element[flag].value = Keybindlist.element[flag]:Label({flag = Library:Random(), cfg = false, Alignment = "right", Title = `{value.mode} [{value.keyname}]`})

		Keybindlist.element[flag]:Set("Visible", bool)
	end

	SetMeta(Library.Keybinds, {__call = function(self, ...)
		local args = {...}

		Keybindlist:RegisterKeybind(args[1], args[2], args[2].toggle == nil and args[2].default or args[2].toggle and args[2].default)
	end})

	Keybindlist.functions.title = function(str)
		Keybindlist.instances.title = str
	end

	Keybindlist.functions.visible = function(bool)
		Keybindlist.open = bool == nil and not Keybindlist.open or bool
		Keybindlist.instances.sub_window.Visible = Keybindlist.open
	end

	Keybindlist.functions.size = function(dim2)
		Library:Tween(Keybindlist.instances.sub_window, {}, {Size = dim2})
	end

	Keybindlist.functions.position = function(dim2)
		Library:Tween(Keybindlist.instances.sub_window, {}, {Position = dim2})
	end

	Library:Resize(Keybindlist.instances.resize, Keybindlist.instances.sub_window, Keybindlist, function(delta)
		Keybindlist:Set("Size", delta)
	end)

	Library:Drag(Keybindlist.instances.title, Keybindlist.instances.sub_window, function(delta)
		Keybindlist:Set("Position", delta)
	end)

	return Keybindlist
end

--// Target Info
function Library:TargetInfo(info)
	info = Library:CaseInsensitive(info or {})

	local TargetInfo = {
		title = info.title or "Target Info",
		open = info.open ~= nil and info.open or false,
		callback = info.callback or info.call_back or function() end,

		position = info.position or Vector2.new(3, Library.framework.AbsoluteSize.Y / 2),

		width = info.width or 250,
		height = info.height or 25,

		minwidth = info.minwidth or 100,
		minheight = info.minwidth or 25,

		maxwidth = info.maxwidth or 250,
		maxheight = info.maxheight or 25,

		target = nil,
		connections = {},
		indicator = {},
		element = {},
		signal = {},
		functions = {},
		class = "sub-window",
	}

	SetMeta(TargetInfo, Library)

	TargetInfo.object, TargetInfo.instances = 
		Library.instances.sub_window(Library.hud, TargetInfo)

	function TargetInfo:Element(name, value)
		if TargetInfo.element[name] or TargetInfo.indicator[name] then return end

		if Find({"string", "boolean"}, type(value)) then
			TargetInfo.element[name] = TargetInfo:Label({flag = Library:Random(), cfg = false, Title = name})
			TargetInfo.element[name].value = TargetInfo.element[name]:Label({flag = Library:Random(), cfg = false, Alignment = "right", Title = value})
			return
		end

		TargetInfo.indicator[name] = TargetInfo:Slider({flag = Library:Random(), cfg = false, Indicator = true, Title = name})
		TargetInfo.indicator[name]:Set("Visible", false)
	end

	TargetInfo:Element("Display Name", "None")
	TargetInfo:Element("Name", "None")
	TargetInfo:Element("Health", 0)

	TargetInfo.signal = function(player)
		if #TargetInfo.connections == 0 then return end

		for _, connection in TargetInfo.connections do
			TCall(connection)(player)
		end
	end

	TargetInfo.functions.target = function(player)
		TargetInfo.target = player
		TargetInfo.signal(player)
		TCall(TargetInfo.callback)(player)

		if not TargetInfo.target then		
			TargetInfo.element["Display Name"].value:Set("Title", "None")
			TargetInfo.element.Name.value:Set("Title", "None")

			for _, indicator in TargetInfo.indicator do
				indicator:Set("Default", 0)
				task.delay(.1, function()
					indicator:Set("Visible", false)
				end)
			end

			return 
		end

		TargetInfo.element["Display Name"].value:Set("Title", player.DisplayName)
		TargetInfo.element.Name.value:Set("Title", player.Name)

		if not player.Character then 
			for _, indicator in TargetInfo.indicators do
				indicator:Set("Default", 0)
			end
			return
		end

		for _, indicator in TargetInfo.indicator do
			indicator:Set("Visible", true)
		end

		TargetInfo.indicator.Health:Set("Max", player.Character and player.Character.Humanoid.MaxHealth or 0)
		TargetInfo.indicator.Health:Set("Default", player.Character and player.Character.Humanoid.Health or 0)

		TargetInfo.signal.Health = TargetInfo.signal.Health or Library:Connection(player.Character.Humanoid.Changed, function(property)
			TargetInfo.indicator.Health:Set("Max", player.Character and player.Character.Humanoid.MaxHealth or 0)
			TargetInfo.indicator.Health:Set("Default", player.Character and player.Character.Humanoid.Health or 0)
		end)

	end

	TargetInfo.functions.title = function(str)
		TargetInfo.instances.title = str
	end

	TargetInfo.functions.visible = function(bool)
		TargetInfo.open = bool == nil and not TargetInfo.open or bool
		TargetInfo.instances.sub_window.Visible = TargetInfo.open
	end

	TargetInfo.functions.size = function(dim2)
		Library:Tween(TargetInfo.instances.sub_window, {}, {Size = dim2})
	end

	TargetInfo.functions.position = function(dim2)
		Library:Tween(TargetInfo.instances.sub_window, {}, {Position = dim2})
	end

	Library:Resize(TargetInfo.instances.resize, TargetInfo.instances.sub_window, TargetInfo, function(delta)
		TargetInfo:Set("Size", delta)
	end)

	Library:Drag(TargetInfo.instances.title, TargetInfo.instances.sub_window, function(delta)
		TargetInfo:Set("Position", delta)
	end)

	return TargetInfo
end

--|| Library Functions ||
function Library:ListConfigs()
    local Raw = {}

    for _, Path in listfiles(Library.Folders.Configs) do
        local File = string.gsub(Path, `^{ Library.Folders.Configs }{ Library.Folders.Prefix }`, "")

        Insert(Raw, File)
    end

	return Raw
end

function Library:GetConfig()
	local Config = {}

	for Key, Value in Library.Configs do
		Value = Library.Flags[Key]
		Key = type(Key) == "number" and tostring(Key) or Key

		if type(Value) == "table" and typeof(Value.default) == "Color3" then	
			Config[Key] = {
				default = `rgb({Concat(Library:RGBToTable(Value.default), ", ")})`,
				alpha = Value.alpha
			}

			continue
		end

		if type(Value) == "table" and (Value.mode or Value.key) then
			Config[Key] = {
				mode = Value.mode,
				key = Value.key.Name
			}

			continue
		end

		Config[Key] = Value
	end

	return HttpService:JSONEncode(Config)
end

function Library:SaveConfig(Name)
	local Config = Library:GetConfig()

	writefile(`{ Library.Folders.Configs }{ Library.Folders.Prefix }{ Name }.{ Library.Folders.Format }`, Config)
end

function Library:LoadConfig(Name)
	local Json = readfile(`{ Library.Folders.Configs }{ Library.Folders.Prefix }{ Name }`)

	if not Json then 
		return 
	end 

	local Config = HttpService:JSONDecode(Json)

	for Key, Value in Config do
		Key = tonumber(Key) or Key

		local Element = Library.Configs[Key]

		if not Element then continue end

		if type(Value) == "table" and (type(Value.default) == "string" and Match(Value.default, "rgb%((.+)%)") )then
			Value.default = Split(Match(Value.default, "rgb%((.+)%)"), ", ")
			Value.default = Rgb(Unpack(Value.default))

			Element:Set("Default", Value.default, Value.alpha)
			continue
		end

		if type(Value) == "table" and (Value.mode or Value.key) then
			Element:Set("Mode", Value.mode)
			Element:Set("Key", Value.key)

			continue
		end

		Element:Set("Default", Value)
	end
end

function Library:GetValue()
	if not self.default then return end

	return self.default
end

function Library:Set(name, ...)
	if type(name) ~= "string" or not self.functions[name:lower()] then return end

	self.functions[name:lower()](...)
end

function Library:Connect(callback)
	Insert(self.connections, callback)

	return self
end

function Library:Disconnect(callback)
	Remove(self.connections, callback)
end

function Library:Unload()
	for _, connection in Library.Connections do 
		connection:Disconnect() 
	end 
	Library.holder:Destroy()
end 

Library.__index = Library

return Library
